\documentclass[sigconf,review]{acmart}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmlicensed}
\copyrightyear{2024}
\acmYear{2024}
\acmDOI{XXXXXXX.XXXXXXX}
\acmBooktitle{Companion Proceedings of the 32nd ACM Symposium on the Foundations of Software Engineering (FSE '24), July 15--19, 2024, Porto de Galinhas, Brazil}



%%
%% These commands are for a JOURNAL article.
%% \acmJournal{JDS}
%% \acmVolume{37}
%% \acmNumber{4}
%% \acmArticle{111}
%% \acmMonth{8}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}




%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.


\title{Semantic Conflict Analysis in Continuous Software Integration with Semantic Merging Tool}


%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.


\author{Matheus Barbosa}
\email{mbo2@cin.ufpe.br}
\orcid{0000-0001-8758-2389}
\affiliation{%
  \institution{Centro de Informática}
  \institution{Universidade Federal de Pernambuco}
  \city{Recife}
  \state{Pernambuco}
  \country{Brazil}
}


%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
%%\renewcommand{\shortauthors}{Trovato et al.}
%%
%% Article type: Research, Review, Discussion, Invited or position
\acmArticleType{Research}
%%
%% Links to code and data
%%\acmCodeLink{https://github.com/borisveytsman/acmart}
%%\acmDataLink{htps://zenodo.org/link}
%%
%% Authors' contribution
%%\acmContributions{BT and GKMT designed the study; LT, VB, and AP
%%  conducted the experiments, BR, HC, CP and JS analyzed the results,
%%   writing the manuscript.}
%%
%% Sometimes the addresses are too long to fit on the page.  In this
%% case uncomment the lines below and fill them accodingly.
%%
%% \authorsaddresses{Corresponding author: Ben Trovato,
%% \href{mailto:trovato@corporation.com}{trovato@corporation.com};
%% Institute for Clarity in Documentation, P.O. Box 1212, Dublin,
%% Ohio, USA, 43017-6221}
%%
%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{conflitos de integração de código, ferramenta de merge semântica}


\begin{abstract}
As funcionalidades do sistema de controle de versão possibilitam que os desenvolvedores realizem suas tarefas de desenvolvimento de maneira autônoma. Além disso, essas ferramentas simplificam a incorporação de alterações por meio de operações de merge e identificam conflitos de texto.
Conflitos textuais são adversidades significativas, no entanto, existem outras formas de conflitos que podem ser ainda mais prejudiciais e não são identificados pelas ferramentas de merge atualmente disponíveis.
Conflitos semânticos dinâmicos referem-se a situações em que não há conflitos textuais aparentes durante o relatórios de merge, porém, resultam em interferências indesejadas que podem ocasionar comportamentos inesperados do programa durante sua execução.
Atualmente, há uma variedade de ferramentas disponíveis que adotam abordagens diversas para enfrentar esse desafio. Estas incluem desde análises estáticas até a implementação de testes automatizados.
Contudo, é observado que a abordagem centrada em testes geralmente resulta em um maior número de falsos negativos, enquanto as análises estáticas tendem a apresentar uma incidência maior de falsos positivos.
Adicionalmente, essas ferramentas estão limitadas a identificar interferências que ocorrem dentro do mesmo método ou em métodos subsequentes, o que pode não refletir a complexidade real dos sistemas. Além disso, foram avaliadas principalmente em cenários de código aberto, sem a inserção direta de intervenção humana em ambientes corporativos.
Neste estudo, propomos o aprimoramento nas análises estáticas para possibilitar sua execução com diferentes pontos de entrada, visando identificar interferências em diferentes áreas de um sistema. Além disso, propomos a criação de uma infraestrutura que integra o processo de merge do Git, a ser implementada nas máquinas dos desenvolvedores em um contexto corporativo. Isso viabilizará a coleta de relatórios de merge e a condução de avaliações qualitativas com a participação ativa dos profissionais envolvidos.
\end{abstract}


%%A proposta deverá abranger:

%Estágio do seu doutorado – inicial (1-3 anos) ou tardio (4+ anos) e qual feedback (por exemplo, ideia de pesquisa, preparação para o mercado de trabalho) você pode querer do simpósio;
%Problema de pesquisa que você está abordando e sua importância para a área;
%Descrição da abordagem proposta e avaliação;
%Contribuições esperadas de sua pesquisa;
%Resultados alcançados até agora;

\maketitle

\section{INTRODUCTION}

As ferramentas de merge textual, que operam com base nas linhas de código, identificam conflitos ao mesclar duas versões que aplicam alterações às mesmas linhas ou a linhas consecutivas \cite{accioly2018understanding}. Embora esses \emph{conflitos textuais} ou conflitos de \emph{merge} sejam comuns e extensivamente estudados, não representam o único problema ao integrar o código de dois desenvolvedores.

Devido à sua limitação em considerar apenas a combinação de linhas, as ferramentas de merge textual não conseguem detectar alterações incompatíveis que ocorrem em áreas do código separadas por pelo menos uma única linha. Por exemplo, se um desenvolvedor altera a assinatura de um método e outro adiciona uma chamada ao método com a assinatura original, mas em linhas diferentes, as ferramentas de merge textual integram o código sem conflitos ou alertas. No entanto, o código resultante pode não compilar, o que configura um \emph{conflito semântico estático} \cite{sarma2011palantir, brun2013early, towqir2022detecting, silva2022detecting, zhang2022using,sung2020towards}. Também chamado de conflito de \emph{Build} .

Além disso, essas ferramentas não conseguem identificar \emph{conflitos semânticos dinâmicos} \cite{Horwitz1989IntegratingNV, yang1992program, shao2009sca, brun2013early, pastore2017bdci, barros2017using, sousa2018verified, da2020detecting, zhang2022using}, que ocorrem quando as alterações de um desenvolvedor afetam um elemento de estado acessado pelo código alterado por outro desenvolvedor, resultando em um comportamento inesperado durante a execução do programa. Visto que não gera conflito de \textit{merge}, pode aumentar as chances de ocorrência de outros conflitos \cite{lima2014abordagem}. Conflitos de \emph{teste} e de \emph{produção} (e não detectados) correspondem a conflitos semânticos dinâmicos.

Conflitos semânticos têm o potencial de prejudicar tanto a eficiência do desenvolvimento quanto a qualidade dos produtos de software. Este impacto é particularmente notável em projetos com bifurcações divergentes, conforme discutido em estudos anteriores~\cite{sung2020towards, zhang2022using, mens2002state, zimmermann2007mining, bird2012assessing, brun2013early}. Contudo, mesmo em projetos que possuem apenas um repositório remoto, esses conflitos podem representar desafios significativos.

Diversas abordagens têm sido exploradas para lidar com a detecção de conflitos semânticos. Por exemplo, a geração de testes \cite{silva2022detecting} tem sido utilizada, mas enfrenta o desafio de altas taxas de falsos negativos, uma vez que verifica a interferência com base em valores de entrada específicos durante a execução do código testado.

Por outro lado, algoritmos de análise estática foram propostos para identificar conflitos semânticos \cite{barros2017using, binkley1995program, Horwitz1989IntegratingNV}, utilizando grafos complexos, como os System Dependence Graphs. Entretanto, à medida que o tamanho das bases de código aumenta, essas abordagens sofrem uma degradação significativa de desempenho, tornando-as impraticáveis para aplicações em bases de código reais com mais de 50 mil linhas de código. Diante desse cenário, surge a necessidade de explorar simplificações nos algoritmos existentes, visando a detecção de conflitos semânticos com menor custo computacional.

Recentemente, em nossa pesquisa, introduzimos a utilização de análises estáticas simplificadas \cite{galileu}, focadas exclusivamente na versão mesclada do código. Nossa abordagem envolve a marcação dessa versão com metadados que indicam quais instruções foram modificadas ou adicionadas por cada desenvolvedor. Contudo, esta abordagem enfrenta dois desafios significativos. Em primeiro lugar, essas ferramentas estão restritas a identificar interferências que se manifestam dentro do mesmo método ou em métodos subsequentes, o que pode não representar adequadamente a complexidade inerente aos sistemas reais. Em segundo lugar, sua avaliação foi predominantemente conduzida em ambientes de código aberto, onde a intervenção humana direta em contextos corporativos não foi considerada. 

Nesse contexto, este estudo propõe aprimoramentos nas análises estáticas, visando à sua adaptação para operar com diversos pontos de entrada, a fim de identificar interferências em diferentes áreas de um sistema. Além disso, o artigo apresenta uma investigação sobre o uso de análises estáticas simplificadas para detectar interferências, com a participação de desenvolvedores reais em seus ambientes de trabalho.

\section{BACKGROUND AND RELATED WORK}
Nesta seção, apresentamos uma revisão dos estudos anteriores que serviram como base de evidência para nossa pesquisa, bem como trabalhos relacionados no campo.

% LEUDSON
Para identificar efetivamente conflitos semânticos, Da Silva \emph{et al} \cite{silva2022detecting} introduziram uma metodologia fundamentada na geração automatizada de testes unitários, os quais servem como especificações parciais para a detecção de interferências em situações de integração. Os autores empregam critérios de aprovação de teste que sugerem interferência: se um teste gerado falhar com a versão base, passar em um dos desenvolvedores e, em seguida, falhar novamente na versão de merge, isso indica que a mudança realizada por um dos desenvolvedores não está preservada na versão mergeada. Em contraste, nossa abordagem se baseia em análise estática. Além disso, esperamos que nosso desempenho seja superior ao deles, embora as informações fornecidas sejam limitadas. A combinação dessas duas técnicas pode ser uma área promissora para futuras investigações.

% Nossa técnica demonstre ser superior no  \emph{recall} mas perde na compração com  \emph{precision}.  

% HORWITZ e ROBERTO
No campo das análises estáticas, Horwitz et al. foram pioneiros no estudo de conflitos semânticos dinâmicos~\cite{Horwitz1989IntegratingNV,horwitz1990interprocedural,yang1992program} e formalizaram a definição de interferência, um conceito central adotado neste estudo. Sua abordagem envolve a construção de Program Dependence Graphs (PDGs)\cite{Horwitz1989IntegratingNV} e System Dependence Graphs (SDGs)\cite{horwitz1990interprocedural} para as quatro versões do programa em um cenário de merge, analisando as diferenças entre eles para detectar e resolver interferências.
Em um trabalho mais recente, Barros Filho \cite{barros2017using}  usando o framework JOANA\cite{joana-paper} propôs a utilização de análises com o objetivo de investigar se o Information Flow Control (IFC) pode ser empregado para identificar a presença de conflitos semânticos dinâmicos entre as contribuições dos desenvolvedores em cenários de merge. No entanto, essas abordagens pode demandar horas para serem construídas, enquanto nossas análises são significativamente mais baratas. 

% GALILEU

Propomos uma técnica leve que explora o uso de análise estática para detectar interferências ao mesclar contribuições de dois desenvolvedores \cite{galileu}. Entretanto, essas análises encontram-se restritas a identificar interferências ocorridas apenas dentro do mesmo método ou em métodos subsequentes, o que possivelmente não representa adequadamente a complexidade intrínseca dos sistemas. No âmbito deste estudo, nossa intenção é aprimorar essas análises, permitindo que operem com diferentes pontos de entrada, permitindo assim a detecção de interferencias em pontos distintos do programa analisado. Além disso, esses trabalhos foram avaliados principalmente em cenários de código aberto, sem a inserção direta de intervenção humana em ambientes corporativos. Nossa proposta busca realizar uma avaliação qualitativa com desenvolvedores em seus ambientes de trabalho reais, visando aprimorar nosso entendimento sobre a usabilidade de ferramentas desse tipo nesse contexto específico.

% SOUSA
Sousa et al.~\cite{sousa2018verified} exploram uma técnica alternativa para detectar interferências. Eles inferem pós-condições relacionais de forma estática a partir das versões do código envolvidas no cenário de merge, estabelecendo restrições sobre as modificações dos elementos de estado por diferentes versões para prevenir interferências. Em seguida, utilizam técnicas de prova de teoremas, como a resolução SMT, para verificar a satisfação dessas restrições. Assim como alguns trabalhos supracitdos, este usa projetos do github para validar a sua aboradgem.

%Algumas propostas, como, por exemplo, Kasi e Sarma\cite{kasi2013cassandra} e Brun et. al.\cite{brun2013early} analisaram cenários de conflitos de projetos open source, visando medir a frequência com que os diferentes tipos de conflitos acontecem. Ambos também apresentaram uma proposta de solução através da implementação de ferramentas, Cassandra e Crystal respectivamente.

%No trabalho de Accioly at. al.\cite{accioly2018analyzing}, foi analisado a eficácia de dois tipos de mudanças de código (edições do mesmo método e edições para métodos diretamente dependentes) como preditores de conflito. Foi analisando parte da história do desenvolvimento de 45 projetos Java de GitHub e Travis CI, incluindo 5.647 cenários de merge, para computar \emph{precision} e o \emph{recall} para os preditores de conflito. Os resultados indicam que os pré-ditadores combinados têm uma precisão de 57,99\% e um recall de 82,67\%. 

%Semelhante ao trabalho supracitado, temos Cavalcanti et. al.\cite{10.1145/3133883}, que apresenta uma comparação entre os métodos de merge textual ou não estruturada e semiestruturada. Foram reproduzidos 30.000 \emph{merges} de 50 open source identificando conflitos relatados incorretamente por uma abordagem, mas não pela outra (falsos positivos), e conflitos relatados corretamente por uma abordagem, mas perdidos pela outra (falsos negativos). Nos resultados e análises complementares indicam melhores resultados para a fusão semiestruturada. Também foi implementada uma ferramenta de merge semiestruturada que combina as duas abordagens para reduzir os falsos positivos e os negativos negativos da merge semiestruturada. Encontraram-se evidências de que a ferramenta, quando comparada à merge não estruturada na amostra estudada, reduz o número de conflitos relatados pela metade, não possui falsos positivos adicionais, tem pelo menos 8\% menos falsos negativos.

%Seguindo a mesma linha, em Shridhar et. al.\cite{10.1145/2652524.2652547} investiga-se qualitativamente a história de 18 projetos open source dos ecossistemas Apache e Eclipse, ao longo de um período de quatorze meses. As alterações de build “corretivas”, “adaptativas” e “novas funcionalidades” introduzem uma rotatividade consideravelmente maior e são mais invasivas, enquanto muitas alterações são identificadas por acidente durante o desenvolvimento regular. Os autores também alertam que ter especialistas dedicados ao processo de build permite que projetos de \emph{software} façam mudanças adaptativas mais invasivas.

%Já em Perry et. al.\cite{10.1145/383876.383878} foi realizado um estudo de caso observacional, em que foram analisados a história de um sistema legado para delinear e compreender a natureza dos problemas encontrados no desenvolvimento paralelo. Os resultados mostram que o grau de paralelismo é muito mais alto quando comparado ao considerado pelos construtores de ferramentas e existem múltiplos níveis de paralelismo, havendo uma correlação significativa entre o grau de trabalho paralelo num determinado componente e o número de problemas apresentados pelos mesmos. 

%Por fim, em Bird e Zimmermann\cite{Bird2012AssessingTV}, caracteriza-se como os desenvolvedores usam ramos em um grande projeto industrial e os problemas comuns enfrentados. Um dos maiores problemas mencionados foi o longo atraso que uma alteração leva para mover-se de um time para outro, problemas este, frequentemente causado pela existência de muitas \emph{branches}. Com o objetivo de monitorar a saúde dos ramos, foi realizada uma análise para avaliar estruturas de ramos com relação a duas propriedades: isolamento e vivacidade. Este modelo de análise foi aplicado em diversos cenários, inclusive no Windows, onde, segundo os autores, as alterações teriam economizado 8 a 9 dias de atraso.

\section{COMPLETED WORK}

\subsection{Semantic conflict detection with overriding assignment analysis}
Propomos e implementamos uma análise de sobreposição de atribuições, que visa detectar interferência entre alterações introduzidas por dois desenvolvedores diferentes, onde caminhos de escrita, sem atribuições intermediárias, para um alvo comum indicam interferência. Para avaliar as implementações da análise proposta, foram comparados os resultados da análise para um conjunto de 78 cenários de integração de código com o Ground Truth para Overriding Assignment (OA) e Local Observable Interference (LOI). Os resultados mostraram que a análise proposta conseguiu detectar interferências entre as modificações, indicando sua eficácia como ferramenta para detecção de conflitos semânticos. No entanto, houve uma quantidade considerável de falsos negativos, sugerindo que a análise por si só não é suficiente para uma detecção confiável de interferências. A precisão da análise foi de 0,44 para a abordagem intraprocedural e 1,0 para a abordagem interprocedural, com uma acurácia de 0,7 e 0,88, respectivamente. Os resultados também destacaram a necessidade de combinar a análise proposta com outras técnicas para criar uma ferramenta mais robusta de detecção de conflitos de integração semânticos. 
Mais detalhes deste trabalho podem ser encontrados em nosso artigo \cite{10.1145/3555228.3555242}

\subsection{Lightweight Semantic Conflict Detection with Static Analysis}
Neste trabalho, nos concentramos em conflitos semânticos dinâmicos, que ocorrem quando os relatórios de merge não apresentam conflitos textuais, mas resulta em interferências indesejadas, causando comportamento inesperado do programa em tempo de execução.
Para resolver esse problema, propomos uma técnica leve que explora o uso de quatro análises estáticas (Interprocedural Data Flow, Interprocedural
Confluence, Interprocedural Override Assignment, and Program Dependence Graph, which includes the control
dependency that detects the interference) para detectar interferências ao mesclar contribuições de dois desenvolvedores.
Avaliamos nossa técnica usando um conjunto de 99 unidades experimentais extraídas de cenários de merge de projetos do GitHub e escolhidos principalmente de trabalhos anteriores relacionados a conflitos semânticos. 
Os resultados fornecem evidências de que nossa técnica apresenta capacidade significativa de detecção de interferências. Ele supera, em termos de pontuação F1 e recall, técnicas anteriores que dependem de análises baseadas em testes para detectar conflitos semânticos, mas apresentam melhor precisão.
A precisão de nossa técnica é comparável às observadas em outros estudos que também utilizam análise estática ou utilizam técnicas de prova de teoremas para detectar conflitos semânticos, embora com desempenho de execução significativamente melhorado. Esses resultados evidenciam a capacidade da análise estática em detectar interferências de forma significativa durante o processo de merge de código. Mais detalhes deste trabalho podem ser encontrados em nosso artigo \cite{galileu}

\section{CONTRIBUTION TO KNOWLEDGE}

Apesar dos avanços nas ferramentas de merge, ainda existem desafios significativos na detecção de conflitos semânticos dinâmicos durante o processo de integração de software. Diversas ferramentas buscam abordagens variadas para resolver esse problema, porém enfrentam desafios de desempenho ou limitações na detecção de interferências que ocorrem apenas dentro do mesmo método ou em métodos subsequentes. Além disso, é comum que essas ferramentas nunca tenham sido testadas quanto à sua usabilidade por seres humanos.

Em nosso trabalho, propomos a criação de uma infraestrutura que integra o processo de merge do Git, a ser implementada nas máquinas dos desenvolvedores em um contexto corporativo visando identificar interferências entre as alterações introduzidas por dois desenvolvedores diferentes e realizar um estudo qualitativo buscando aprimorar nosso entendimento sobre a usabilidade de ferramentas desse tipo, nesse contexto específico.

O trabalho de doutorado encontra-se em uma fase inicial, completando recentemente dois anos de pesquisa dedicada. Como destacado em estudos anteriores, já conseguimos validar a eficácia da análise estática em identificar conflitos semânticos em ambientes de desenvolvimento, utilizando repositórios relevantes hospedados no GitHub. Agora, almejamos avançar nesse campo, buscando aplicar nossa metodologia em ambientes reais de trabalho, com desenvolvedores ativos em empresas de diversos setores.

Nossa proposta consiste em integrar nossa ferramenta diretamente nos fluxos de trabalho desses profissionais, permitindo-nos capturar dados detalhados durante a execução. Ao coletar registros dessas interações, teremos acesso a uma visão mais precisa e abrangente do uso da ferramenta em cenários práticos. Essa abordagem nos possibilitará não apenas validar a eficácia da análise estática em um contexto mais dinâmico e complexo, mas também entender melhor as necessidades e desafios enfrentados pelos desenvolvedores no dia a dia.

A partir desses dados, poderemos gerar relatórios mais informativos e relevantes, oferecendo insights valiosos tanto para os desenvolvedores quanto para as equipes de pesquisa e desenvolvimento. Esperamos que essa colaboração direta com profissionais da área não apenas fortaleça a validade de nossa abordagem, mas também contribua para o avanço do conhecimento e práticas na detecção e resolução de conflitos semânticos em projetos de software.

\section*{ACKNOWLEDGMENTS}
O autor recebeu orientação do Dr. Paulo Borda, Membro da ACM e da Sociedade Brasileira de Computação, professor de Engenharia de Software no Centro de Informática da Universidade Federal de Pernambuco e líder do Grupo de Produtividade de Software. Atualmente também é diretor do Centro de Informática.

Este trabalho conta com apoio parcial das bolsas IBPG-0567-1.03/22 da Fundação de Amparo à Ciência e Tecnologia do Estado de Pernambuco. Quaisquer opiniões, descobertas e conclusões expressas neste trabalho são de responsabilidade exclusiva do autor e não refletem necessariamente as dos patrocinadores.

We would like to thank INES (National Software Engineering Institute) and CNPQ.


\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

\end{document}
\endinput